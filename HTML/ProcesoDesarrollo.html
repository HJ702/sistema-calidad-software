<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Proceso de Desarrollo de Software</title>
  <link rel="stylesheet" href="../CSS/ProcesoDesarrollo.css" />
</head>
<body>
  <header class="header">
    <h1>Proceso de Desarrollo de Software</h1>
    <h2>Fases, Modelos y Buenas Prácticas</h2>
  </header>

  <main class="container">
    <a href="PaginaPrincipal.html" class="flecha" title="Volver a la página principal">←</a>

    <section class="intro card">
      <h3>Introducción</h3>
      <p>
        El proceso de desarrollo de software es el conjunto estructurado de actividades que permiten planificar, diseñar, implementar, probar y mantener un sistema informático. Este proceso busca garantizar la calidad, eficiencia y mantenibilidad del producto final, mediante la aplicación de metodologías, estándares y buenas prácticas de ingeniería de software.
      </p>
    </section>

    <section class="phase card">
      <h3>1. Análisis de Requisitos</h3>
      <p>
        En esta etapa se realiza la captura, análisis y especificación de los requisitos funcionales y no funcionales del sistema. El objetivo es comprender con precisión qué necesita el cliente y qué funciones deberá cumplir el software.
      </p>
      <h4>Actividades principales:</h4>
      <ul>
        <li>Reunión con el cliente y los usuarios finales.</li>
        <li>Identificación de requisitos del sistema y del entorno.</li>
        <li>Elaboración del documento de Especificación de Requisitos de Software (ERS o SRS).</li>
        <li>Validación de requisitos mediante revisiones y prototipos.</li>
      </ul>
      <h4>Resultados:</h4>
      <ul>
        <li>Documento de requisitos aprobado.</li>
        <li>Casos de uso o historias de usuario.</li>
      </ul>
    </section>

    <section class="phase card">
      <h3>2. Diseño del Sistema</h3>
      <p>
        El diseño traduce los requisitos en una arquitectura de software que defina la estructura del sistema, los componentes y sus interacciones.
      </p>
      <h4>Subfases:</h4>
      <ul>
        <li><strong>Diseño arquitectónico:</strong> define la estructura general (capas, módulos, patrones).</li>
        <li><strong>Diseño detallado:</strong> especifica algoritmos, estructuras de datos e interfaces.</li>
        <li><strong>Diseño de base de datos:</strong> modela la información que el sistema manipulará.</li>
      </ul>
      <h4>Principios clave:</h4>
      <ul>
        <li>Modularidad.</li>
        <li>Alta cohesión y bajo acoplamiento.</li>
        <li>Reutilización de componentes.</li>
        <li>Documentación con diagramas UML (casos de uso, clases, secuencia, componentes, etc.).</li>
      </ul>
    </section>

    <section class="phase card">
      <h3>3. Implementación o Codificación</h3>
      <p>
        Consiste en la traducción del diseño a código fuente mediante lenguajes de programación apropiados (Java, Python, C#, etc.). Durante esta fase se aplican prácticas de ingeniería como la programación estructurada, orientada a objetos o basada en componentes.
      </p>
      <h4>Buenas prácticas:</h4>
      <ul>
        <li>Uso de control de versiones (Git).</li>
        <li>Revisión de código (code review).</li>
        <li>Pruebas unitarias automatizadas.</li>
        <li>Documentación técnica del código.</li>
      </ul>
    </section>

    <section class="phase card">
      <h3>4. Pruebas (Testing)</h3>
      <p>
        El objetivo es verificar y validar el funcionamiento del software para asegurar que cumple los requisitos establecidos y está libre de defectos.
      </p>
      <h4>Tipos de pruebas:</h4>
      <ul>
        <li><strong>Unitarias:</strong> verifican funciones individuales.</li>
        <li><strong>De integración:</strong> evalúan la interacción entre módulos.</li>
        <li><strong>De sistema:</strong> comprueban el comportamiento completo.</li>
        <li><strong>De aceptación:</strong> realizadas por el cliente antes de la entrega final.</li>
      </ul>
      <p>
        Se emplean marcos de trabajo como <strong>JUnit</strong>, <strong>Selenium</strong> o <strong>Postman</strong>, según el tipo de prueba.
      </p>
    </section>

    <section class="phase card">
      <h3>5. Implementación o Despliegue</h3>
      <p>
        Implica la instalación y configuración del software en el entorno operativo real. Puede incluir migración de datos, configuración de servidores y capacitación a usuarios.
      </p>
      <h4>Estrategias comunes:</h4>
      <ul>
        <li>Despliegue gradual o por fases.</li>
        <li>Despliegue continuo (CI/CD).</li>
        <li>Contenerización con Docker o Kubernetes.</li>
      </ul>
    </section>

    <section class="phase card">
      <h3>6. Mantenimiento</h3>
      <p>
        Es la fase más prolongada del ciclo de vida del software. Incluye la corrección de errores, mejoras funcionales y actualizaciones tecnológicas necesarias para garantizar la vigencia y adaptabilidad del sistema.
      </p>
      <h4>Tipos de mantenimiento:</h4>
      <ul>
        <li><strong>Correctivo:</strong> reparación de defectos detectados.</li>
        <li><strong>Adaptativo:</strong> adecuación a nuevos entornos o plataformas.</li>
        <li><strong>Perfectivo:</strong> mejora del rendimiento o funcionalidad.</li>
        <li><strong>Preventivo:</strong> optimización del código para evitar futuros problemas.</li>
      </ul>
    </section>

    <!-- ===================== -->
    <!-- NUEVA SECCIÓN: MODELOS -->
    <!-- ===================== -->
    <section class="models card">
      <h3>Modelos de Proceso de Desarrollo</h3>
      <ul>
        <li><strong>Modelo en Cascada:</strong> secuencial y rígido, adecuado para proyectos con requisitos bien definidos.</li>
        <li><strong>Modelo Incremental:</strong> el sistema se construye por versiones sucesivas y funcionales.</li>
        <li><strong>Modelo en Espiral:</strong> incorpora análisis de riesgos y desarrollo iterativo.</li>
        <li><strong>Modelo Ágil (Scrum, Kanban, XP):</strong> basado en iteraciones cortas, retroalimentación continua y adaptación al cambio.</li>
        <li><strong>Modelo en V:</strong> combina desarrollo y pruebas en paralelo.</li>
      </ul>
    </section>

    <section class="extra card">
      <h3>Ventajas y Desventajas del Modelo Incremental</h3>
      <h4>Ventajas</h4>
      <ul>
        <li>Entregas tempranas: los usuarios pueden empezar a usar partes del sistema antes de esperar la versión final.</li>
        <li>Adaptabilidad ante cambios entre incrementos.</li>
        <li>Menor riesgo: fallos se detectan antes.</li>
        <li>Mejora continua y refinamiento progresivo.</li>
        <li>Más manejable al trabajar por partes.</li>
      </ul>

      <h4>Desventajas</h4>
      <ul>
        <li>Arquitectura global más compleja.</li>
        <li>Posible acumulación de deuda técnica.</li>
        <li>Costos mayores si no se controla la integración.</li>
        <li>Priorización incorrecta puede retrasar valor real.</li>
      </ul>

      <h4>Cuándo usarlo</h4>
      <ul>
        <li>Cuando los requisitos no están completamente definidos al inicio.</li>
        <li>Proyectos medianos o grandes divididos en fases.</li>
        <li>Cuando se espera retroalimentación constante de usuarios.</li>
        <li>En enfoques ágiles híbridos.</li>
      </ul>
    </section>

    <section class="spiral card">
      <h3>Modelo en Espiral</h3>
      <p>
        Propuesto por Barry Boehm, combina elementos de los modelos en cascada e iterativos, con un enfoque fuerte en el análisis de riesgos. Cada vuelta de la espiral representa una versión más completa del sistema.
      </p>
      <h4>Fases del ciclo:</h4>
      <ul>
        <li><strong>Determinación de objetivos:</strong> definir metas, funcionalidades y restricciones.</li>
        <li><strong>Identificación de riesgos:</strong> evaluar problemas y alternativas.</li>
        <li><strong>Desarrollo e implementación:</strong> construir el módulo y probarlo.</li>
        <li><strong>Evaluación y planificación:</strong> revisión de resultados y preparación del siguiente ciclo.</li>
      </ul>

      <h4>Ventajas</h4>
      <ul>
        <li>Excelente gestión de riesgos.</li>
        <li>Alta flexibilidad ante cambios.</li>
        <li>Desarrollo progresivo con feedback constante.</li>
        <li>Ideal para proyectos grandes o inciertos.</li>
      </ul>

      <h4>Desventajas</h4>
      <ul>
        <li>Complejo y costoso en planificación.</li>
        <li>Difícil de estimar tiempo total.</li>
        <li>No recomendable para proyectos pequeños.</li>
      </ul>

      <h4>Cuándo usarlo</h4>
      <ul>
        <li>Proyectos grandes y complejos con alta incertidumbre.</li>
        <li>Cuando el riesgo técnico o de negocio es alto.</li>
        <li>En proyectos de investigación o evolutivos (I+D).</li>
      </ul>
    </section>

    <section class="agil card">
      <h3>Modelos Ágiles (Scrum, Kanban, XP)</h3>
      <p>
        Los modelos ágiles se basan en valores y principios que priorizan la entrega rápida de valor, la adaptabilidad y la colaboración constante entre los equipos.
      </p>

      <h4>Scrum</h4>
      <ul>
        <li><strong>Roles:</strong> Product Owner, Scrum Master, Equipo de Desarrollo.</li>
        <li><strong>Artefactos:</strong> Product Backlog, Sprint Backlog, Incremento, Definition of Done.</li>
        <li><strong>Eventos:</strong> Sprint Planning, Daily Scrum, Sprint Review, Sprint Retrospective.</li>
      </ul>

      <h4>Kanban</h4>
      <ul>
        <li>Flujo continuo visual con tableros.</li>
        <li>Límites de trabajo en curso (WIP).</li>
        <li>Mejora continua y detección de cuellos de botella.</li>
      </ul>

      <h4>Extreme Programming (XP)</h4>
      <ul>
        <li>Programación en parejas.</li>
        <li>Integración continua.</li>
        <li>Refactorización constante.</li>
        <li>Pruebas automatizadas (TDD).</li>
        <li>Cliente integrado al equipo.</li>
      </ul>

      <h4>Ventajas</h4>
      <ul>
        <li>Alta flexibilidad y adaptabilidad.</li>
        <li>Entrega frecuente de valor.</li>
        <li>Retroalimentación temprana.</li>
        <li>Fomento de la colaboración y transparencia.</li>
      </ul>

      <h4>Desventajas</h4>
      <ul>
        <li>Requiere compromiso y cultura ágil.</li>
        <li>Puede generar desorden sin disciplina.</li>
        <li>Difícil de escalar en proyectos grandes.</li>
        <li>Depende del feedback continuo del cliente.</li>
      </ul>

      <h4>Cuándo usarlo</h4>
      <ul>
        <li>Proyectos con requisitos cambiantes o inciertos.</li>
        <li>Equipos pequeños a medianos con buena comunicación.</li>
        <li>Cuando se busca mejora continua y entregas frecuentes.</li>
      </ul>

      <h3>Modelo en V</h3>
  <p>
    El <strong>modelo en V</strong> (Validación y Verificación) es una evolución del modelo en cascada 
    que establece una relación directa entre cada fase de desarrollo y su respectiva fase de prueba. 
    Su forma en “V” representa cómo el proceso de definición desciende por la rama izquierda (análisis y diseño) 
    y luego asciende por la derecha (verificación y validación).
  </p>

  <h4>Fases principales:</h4>
  <ul>
    <li><strong>Definición de requisitos:</strong> se identifican y documentan las necesidades del cliente.</li>
    <li><strong>Diseño del sistema:</strong> se establece la arquitectura general del software y hardware.</li>
    <li><strong>Diseño detallado:</strong> se definen los componentes, interfaces y lógica interna.</li>
    <li><strong>Implementación:</strong> se desarrolla el código del sistema según el diseño detallado.</li>
    <li><strong>Pruebas unitarias:</strong> verifican el funcionamiento individual de cada módulo.</li>
    <li><strong>Pruebas de integración:</strong> validan la comunicación y compatibilidad entre módulos.</li>
    <li><strong>Pruebas del sistema:</strong> aseguran que el sistema completo cumple con los requisitos definidos.</li>
    <li><strong>Pruebas de aceptación:</strong> confirman que el producto final satisface las necesidades del cliente.</li>
  </ul>

  <h4>Ventajas:</h4>
  <ul>
    <li>Alta trazabilidad entre fases de desarrollo y pruebas.</li>
    <li>Permite detectar errores de forma temprana y organizada.</li>
    <li>Estructura clara, fácil de entender y de gestionar.</li>
    <li>Ideal para proyectos con requisitos bien definidos y estables.</li>
  </ul>

  <h4>Desventajas:</h4>
  <ul>
    <li>Poca flexibilidad ante cambios durante el desarrollo.</li>
    <li>Retroalimentación del usuario limitada hasta las fases finales.</li>
    <li>No se adapta bien a proyectos con requisitos cambiantes o exploratorios.</li>
  </ul>

  <h4>Aplicaciones comunes:</h4>
  <ul>
    <li>Proyectos donde la validación y la calidad son críticas (aeronáutica, defensa, medicina, automoción).</li>
    <li>Entornos donde se requiere documentación completa y pruebas rigurosas.</li>
  </ul>
    </section>
  </main>

  <footer class="footer">
    <p>© 2025 | Proceso de Desarrollo de Software | Ingeniería de Software</p>
  </footer>
</body>
</html>
